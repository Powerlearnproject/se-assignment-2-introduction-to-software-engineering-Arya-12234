[![Review Assignment Due Date](https://classroom.github.com/assets/deadline-readme-button-24ddc0f5d75046c5622901739e7c5dd533143b0c8e959d652212380cedb1ea36.svg)](https://classroom.github.com/a/-ucQIGTc)
[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-718a45dd9cf7e7f842a935f5ebbe5719a5e09af4491e668f4dbf3b35d5cca122.svg)](https://classroom.github.com/online_ide?assignment_repo_id=15236856&assignment_repo_type=AssignmentRepo)
# SE-Assignment-2
Assignment: Introduction to Software Engineering
Instructions:
Answer the following questions based on your understanding of software engineering concepts. Provide detailed explanations and examples where appropriate.

Questions:
Define Software Engineering:
Software Engineering is the process of development of of software products using well defined scientific methods, principles and procedures.

What is software engineering, and how does it differ from traditional programming?
Software engineering focuses on a systematic process that has a structured and methodical approach to programming while Traditional programming focuses on a ad-hoc approach that uses less formal and structural approach relying more on the programmer's skills and experience.
Software engineering is applied to large scale, complex projects where collaboration is essential while Traditional programming is used for smaller, less complex projects.
Software engineering involves systematic design and architecture to ensure the software meets requirements and is mantainable while Traditional programming emphasizes solving problems through coding and less focus on systematic design and architecture.
Software engineering uses structured methodologies such as waterfall, agile while Traditional programming follow less formal processes often based on the programmer's preferences.


Software Development Life Cycle (SDLC):
Software Development Life Cycle is a framework under the ISO/IEC 12207 used in software development to design, develop and test high quality softwares.


Explain the various phases of the Software Development Life Cycle. Provide a brief description of each phase.
Agile vs. Waterfall Models:
Agile Model
Is a combination of iterative and incremental process models with focus on process adaptability and customer satisfaction by rapid delivery of working software product.
Agile model breaks the product into small incremental builds.
These builds are provided in iterations.
Every iteration involves cross functional teams working simultaneously on various areas like:
1. Planning.
2. Requirements and analysis.
3. Design.
4. Coding.
5. Unit Testing and 
6. Acceptance Testing.
Waterfall Model
Also referred to as linear sequential life cycle model.
In a waterfall model each phase must be completed before the next phase can begin and no overlapping in the phases.
The sequential phases are:
1. Requirements gathering and analysis where the requirements of the system are developed.
2. System design helps in designing overall system architecture.
3. Implementation where each unit is developed and tested for its functionality, which is referred to as Unit testing.
4. Integration and Testing where all the units developed in the implementation phase are integrated into a system after testing each unit.
5. Deployment of the system once the testing is done, the product is deployed in the market.
6. Maintenance is done to deliver changes in the customer environment for example when patches are released.


Compare and contrast the Agile and Waterfall models of software development. What are the key differences, and in what scenarios might each be preferred?
Waterfall model is a linear sequential process where development proceeds through a series of defined phases while Agile model has an iterative and incremental process where development is divided into small iterative cycles called sprints.
Waterfall model requirements are gathered and documented at the beginning of the project while in Agile model
there is customer collaboration where there is continuos involvement and feedback from customers and stakeholders.
Waterfall model has predictability and is structured which makes it easier to predict timelines, costs and resources needed while Agile model has flexibility and adaptability because it embraces changes in requirements even late in development and adapts to evolving needs and priorities.

Scenarios where waterfall model maybe preferred:
1. Fixed and clear requirements.
2. Large and complex systems.
3. Well defined deliverables.
Scenarios where agile model maybe preferred:
1. Evolving requirements.
2. Customer collaboration.
3. Rapid delivery.

Requirements Engineering:
Is the process of collecting information about a product so that it fits customers specification and satisfaction.

What is requirements engineering? Describe the process and its importance in the software development lifecycle.
Importance of requirements gathering.
1. Quality products.
2. Facilitates testing and validation.
3. Cost efficiency.
4. Planning and estimation.
5. Communication between the respective parties.
Software Design Principles:

Explain the concept of modularity in software design. How does it improve maintainability and scalability of software systems?
Modularity is a fundamental concept in software design that involves dividing a software system into smaller, manageable, and independent modules or components. Each module encapsulates a specific functionality or a set of related functionalities and interacts with other modules through well-defined interfaces.
How it improves mantainability and scalability:
1. Encapsulation.
2. Easier debugging and testing.
3. Code readability.
4. Flexible deployment.
5. Facilitates integration.

Testing in Software Engineering:

Describe the different levels of software testing (unit testing, integration testing, system testing, acceptance testing). Why is testing crucial in software development?
Unit testing concentrates on the tiniest aspect of software development. For examples in a programme we check whether the loop, method is functioning properly.
Integration Testing entails combining a number of components to achieve a result. For example testing in a whitebox.
System testing is where a programme has been thoroughly tested to ensure that it is compatible with a variety of operating systems. For example performance testing.
Importance of testing:
1. Improves user satisfaction.
2. Enhances quality and reliability.
3. Reduces development costs.
4. Enhances security.
5. Facilitates maintenance and updates.

Version Control Systems:

What are version control systems, and why are they important in software development? Give examples of popular version control systems and their features.
Version control systems (VCS) are tools used in software development to manage changes to source code over time. 
They enable multiple developers to collaborate on a project, keep track of every modification to the code, and maintain a history of changes.
Importance of version control systems:
1. Collaboration.
2. History and tracking.
3. Back up and recovery.
4. Code integrity.
5. Conflict resolution.
Examples of VCS:
1. GIT: Features
Distributed nature allows for offline work.
Staging area (index) for intermediate commits.
Powerful branching model.
2. Subversion(SVN): Features
Atomic commits ensure complete changes.
Support for binary files.
Comprehensive history and change tracking.
3. Perforce(Helix core): Features
Excellent performance with large code bases.
Strong integration with IDEs and other development tools.
Built-in code review system (Helix Swarm).
4. Mercurial: Features
Easy branching and merging.
Built-in web interface.
Extensive documentation and tutorials.

Software Project Management:

Discuss the role of a software project manager. What are some key responsibilities and challenges faced in managing software projects?
A software project manager plays a crucial role in overseeing and guiding software development projects from inception to completion. They ensure that projects are completed on time, within budget, and to the required quality standards while meeting stakeholders' expectations.
Responsibilities:
1. Project planning.
2. Team leadership.
3. Communication.
4. Risk assessment.
5. Quality assurance.
Challenges:
1. Time management.
2. Resource constraints.
3. Communication barriers.
4. Technology challenges.
5. Team dynamic.
Software Maintenance:

Define software maintenance and explain the different types of maintenance activities. Why is maintenance an essential part of the software lifecycle?
Software maintenance refers to the process of modifying, updating, and enhancing a software product after it has been delivered and deployed. It involves making changes to the software to correct defects, improve performance, adapt to changes in the environment, and add new features. 
Importance:
1. Adaptation to change.
2. Enhancement of features.
3. User satisfaction.
4. Risk mitigation.
5. Performance optimization.
Ethical Considerations in Software Engineering:

What are some ethical issues that software engineers might face? How can software engineers ensure they adhere to ethical standards in their work?
Ethical issues:
1. Intellectual Property.
2. User consent and control.
3. Security vulnerabilities.
4. Privacy concerns.
5. Safety and reliability.
Ethical standards:
1. Ethics training.
2. Transparency and accountability.
3. Risk assessment.
4. Ethical guidelines and code of conduct.
5. User-centric design.
Submission Guidelines:
Your answers should be well-structured, concise, and to the point.
Provide real-world examples or case studies wherever possible.
Cite any references or sources you use in your answers.
Submit your completed assignment by [due date].
